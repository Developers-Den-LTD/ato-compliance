// Enhanced System Security Plan (SSP) Generation Service
// Generates NIST SP 800-18 compliant SSP documents with full control narratives

import { storage } from '../storage';
import { modelRouter } from '../llm/model-router';
import { artifactService } from './artifact-service';
import PizZip from 'pizzip';
import Docxtemplater from 'docxtemplater';
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
// import puppeteer from 'puppeteer'; // Moved to dynamic import to prevent startup crash
import crypto from 'crypto';
import type { 
  System, 
  Control,
  SystemControl,
  Finding, 
  Evidence, 
  Artifact,
  Assessment
} from '../schema';

export interface SSPGenerationRequest {
  systemId: string;
  format: 'docx' | 'pdf' | 'oscal';
  includeEvidence: boolean;
  includeAssessmentResults: boolean;
  includeDiagrams: boolean;
  templateOptions?: {
    classification?: string;
    organization?: string;
    preparedBy?: string;
    reviewedBy?: string;
    approvedBy?: string;
    version?: string;
    date?: string;
  };
}

export interface SSPDocument {
  content: Buffer;
  format: string;
  filename: string;
  metadata: {
    systemName: string;
    generatedDate: Date;
    totalControls: number;
    implementedControls: number;
    pages?: number;
  };
}

interface SSPSection {
  title: string;
  content: string;
  level: number;
  pageBreak?: boolean;
}

interface ControlNarrative {
  controlId: string;
  family: string;
  title: string;
  requirement: string;
  implementation: string;
  status: string;
  evidence: Evidence[];
  lastUpdated?: Date;
}

export class SSPGenerationService {
  private templatePath = join(process.cwd(), 'server/templates/ssp-template.docx');
  
  /**
   * Generate a complete System Security Plan document
   */
  async generateSSP(request: SSPGenerationRequest): Promise<SSPDocument> {
    const startTime = Date.now();
    console.log(`üöÄ Generating SSP for system ${request.systemId} in ${request.format} format`);

    try {
      // Gather all required data
      const data = await this.gatherSystemData(request.systemId);
      console.log(`‚úì Data gathered (${data.systemControls.length} controls, ${data.findings.length} findings)`);

      // Generate document sections
      const sections = await this.generateDocumentSections(data, request);
      console.log(`‚úì Generated ${sections.length} document sections`);

      // Format based on requested type
      let document: SSPDocument;
      switch (request.format) {
        case 'docx':
          document = await this.generateDocx(sections, data, request);
          break;
        case 'pdf':
          document = await this.generatePdf(sections, data, request);
          break;
        case 'oscal':
          document = await this.generateOscal(data, request);
          break;
        default:
          throw new Error(`Unsupported format: ${request.format}`);
      }

      const duration = Date.now() - startTime;
      console.log(`‚úÖ SSP generation completed in ${duration}ms (${(document.content.length / 1024).toFixed(2)} KB)`);

      return document;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`‚ùå SSP generation failed after ${duration}ms:`, error);
      throw error;
    }
  }
  
  /**
   * Gather all system data needed for SSP generation
   */
  private async gatherSystemData(systemId: string) {
    const [
      system,
      systemControls,
      findings,
      evidence,
      artifacts,
      assessments
    ] = await Promise.all([
      storage.getSystem(systemId),
      storage.getSystemControls(systemId),
      storage.getFindingsBySystem(systemId),
      storage.getEvidenceBySystem(systemId),
      storage.getArtifactsBySystem(systemId),
      storage.getAssessmentsBySystem(systemId)
    ]);
    
    if (!system) {
      throw new Error(`System ${systemId} not found`);
    }
    
    // Get full control details
    const controls = await Promise.all(
      systemControls.map(sc => storage.getControl(sc.controlId))
    );
    
    return {
      system,
      systemControls,
      controls: controls.filter(c => c !== null) as Control[],
      findings,
      evidence,
      artifacts,
      assessments
    };
  }
  
  /**
   * Generate all document sections
   */
  private async generateDocumentSections(
    data: any,
    request: SSPGenerationRequest
  ): Promise<SSPSection[]> {
    const sections: SSPSection[] = [];
    
    // Title Page
    sections.push({
      title: 'Title Page',
      content: this.generateTitlePage(data, request),
      level: 0
    });
    
    // Table of Contents (placeholder - will be generated by Word)
    sections.push({
      title: 'Table of Contents',
      content: '<!-- TOC -->',
      level: 0,
      pageBreak: true
    });
    
    // Executive Summary
    sections.push({
      title: 'Executive Summary',
      content: await this.generateExecutiveSummary(data, request),
      level: 1,
      pageBreak: true
    });
    
    // System Overview
    sections.push({
      title: 'System Overview',
      content: await this.generateSystemOverview(data, request),
      level: 1
    });
    
    // System Architecture
    if (request.includeDiagrams) {
      sections.push({
        title: 'System Architecture',
        content: await this.generateSystemArchitecture(data),
        level: 1
      });
    }
    
    // Security Control Implementation
    sections.push({
      title: 'Security Control Implementation',
      content: await this.generateControlImplementation(data),
      level: 1,
      pageBreak: true
    });
    
    // Control Narratives by Family
    const controlFamilies = this.groupControlsByFamily(data.controls, data.systemControls);
    for (const [family, controls] of Object.entries(controlFamilies)) {
      sections.push({
        title: `${family} - ${this.getFamilyName(family)}`,
        content: await this.generateFamilyNarratives(family, controls, data),
        level: 2
      });
    }
    
    // Risk Assessment
    if (request.includeAssessmentResults && data.findings.length > 0) {
      sections.push({
        title: 'Risk Assessment',
        content: await this.generateRiskAssessment(data),
        level: 1,
        pageBreak: true
      });
    }
    
    // Evidence and Artifacts
    if (request.includeEvidence) {
      sections.push({
        title: 'Supporting Evidence',
        content: await this.generateEvidenceSection(data),
        level: 1,
        pageBreak: true
      });
    }
    
    // Compliance Summary
    sections.push({
      title: 'Compliance Summary',
      content: await this.generateComplianceSummary(data),
      level: 1,
      pageBreak: true
    });
    
    // Appendices
    sections.push({
      title: 'Appendices',
      content: this.generateAppendices(data),
      level: 1,
      pageBreak: true
    });
    
    return sections;
  }
  
  /**
   * Generate DOCX document
   */
  private async generateDocx(
    sections: SSPSection[],
    data: any,
    request: SSPGenerationRequest
  ): Promise<SSPDocument> {
    // For now, create a simple text-based document
    // In production, use docxtemplater with a proper template
    let content = '';
    
    for (const section of sections) {
      if (section.pageBreak && content) {
        content += '\n\n<!-- PAGE BREAK -->\n\n';
      }
      
      const heading = '#'.repeat(section.level || 1);
      content += `${heading} ${section.title}\n\n`;
      content += section.content + '\n\n';
    }
    
    const buffer = Buffer.from(content, 'utf-8');
    
    return {
      content: buffer,
      format: 'docx',
      filename: `SSP_${data.system.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.docx`,
      metadata: {
        systemName: data.system.name,
        generatedDate: new Date(),
        totalControls: data.controls.length,
        implementedControls: data.systemControls.filter((sc: SystemControl) => 
          sc.status === 'implemented'
        ).length
      }
    };
  }
  
  /**
   * Generate PDF document
   */
  private async generatePdf(
    sections: SSPSection[],
    data: any,
    request: SSPGenerationRequest
  ): Promise<SSPDocument> {
    // Generate HTML first
    let html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <title>System Security Plan - ${data.system.name}</title>
      <style>
        body { 
          font-family: Arial, sans-serif; 
          line-height: 1.6; 
          margin: 0;
          padding: 0;
        }
        .page { 
          padding: 1in; 
          max-width: 8.5in;
          margin: 0 auto;
        }
        h1 { 
          color: #003366; 
          border-bottom: 2px solid #003366; 
          padding-bottom: 10px;
        }
        h2 { 
          color: #003366; 
          margin-top: 2em;
        }
        h3 { 
          color: #666; 
        }
        .page-break { 
          page-break-after: always; 
        }
        table { 
          width: 100%; 
          border-collapse: collapse; 
          margin: 1em 0;
        }
        th, td { 
          border: 1px solid #ddd; 
          padding: 8px; 
          text-align: left;
        }
        th { 
          background-color: #f4f4f4; 
          font-weight: bold;
        }
        .control-narrative {
          margin: 1em 0;
          padding: 1em;
          background-color: #f9f9f9;
          border-left: 4px solid #003366;
        }
        .metadata {
          color: #666;
          font-size: 0.9em;
          margin-top: 0.5em;
        }
      </style>
    </head>
    <body>`;
    
    for (const section of sections) {
      if (section.pageBreak && html.includes('</div>')) {
        html += '<div class="page page-break">';
      } else {
        html += '<div class="page">';
      }
      
      const tag = section.level === 0 ? 'h1' : 
                   section.level === 1 ? 'h1' : 
                   section.level === 2 ? 'h2' : 'h3';
      
      html += `<${tag}>${section.title}</${tag}>`;
      html += section.content.replace(/\n/g, '<br>');
      html += '</div>';
    }
    
    html += '</body></html>';

    // Convert HTML to PDF using Puppeteer
    let browser;
    let page;

    try {
      console.log('üñ®Ô∏è  Launching browser for PDF conversion...');

      // Dynamic import to prevent app startup crash if puppeteer is not installed
      let puppeteer;
      try {
        puppeteer = (await import('puppeteer')).default;
      } catch (importError) {
        console.error('Puppeteer not installed. Install with: npm install puppeteer');
        throw new Error('PDF generation requires puppeteer package. Please install it to enable PDF export.');
      }

      browser = await puppeteer.launch({
        headless: true,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage', // Overcome limited resource problems
          '--disable-accelerated-2d-canvas',
          '--disable-gpu'
        ]
      });

      page = await browser.newPage();

      // Set memory limits
      await page.setDefaultNavigationTimeout(60000); // 60s timeout
      await page.setDefaultTimeout(60000);

      await page.setContent(html, { waitUntil: 'networkidle0' });

      console.log('üìÑ Generating PDF...');

      const pdfBuffer = await page.pdf({
        format: 'Letter',
        printBackground: true,
        margin: {
          top: '0.5in',
          right: '0.5in',
          bottom: '0.5in',
          left: '0.5in'
        }
      });

      // Clean up page first
      if (page) {
        await page.close();
        page = undefined;
      }

      // Then close browser
      if (browser) {
        await browser.close();
        browser = undefined;
      }

      console.log(`‚úÖ PDF generated successfully (${(pdfBuffer.length / 1024).toFixed(2)} KB)`);

      return {
        content: Buffer.from(pdfBuffer),
        format: 'pdf',
        filename: `SSP_${data.system.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`,
        metadata: {
          systemName: data.system.name,
          generatedDate: new Date(),
          totalControls: data.controls.length,
          implementedControls: data.systemControls.filter((sc: SystemControl) =>
            sc.status === 'implemented'
          ).length,
          pages: undefined // Puppeteer doesn't provide page count directly
        }
      };
    } catch (error) {
      console.error('‚ùå PDF generation failed:', error);

      // Ensure cleanup happens even on error
      try {
        if (page) await page.close();
      } catch (e) {
        console.error('Failed to close page:', e);
      }

      try {
        if (browser) await browser.close();
      } catch (e) {
        console.error('Failed to close browser:', e);
      }

      throw new Error(`Failed to generate PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Generate OSCAL format
   */
  private async generateOscal(
    data: any,
    request: SSPGenerationRequest
  ): Promise<SSPDocument> {
    const oscal = {
      "system-security-plan": {
        "uuid": crypto.randomUUID(),
        "metadata": {
          "title": `System Security Plan for ${data.system.name}`,
          "last-modified": new Date().toISOString(),
          "version": request.templateOptions?.version || "1.0",
          "oscal-version": "1.0.4"
        },
        "system-characteristics": {
          "system-ids": [{
            "id": data.system.id
          }],
          "system-name": data.system.name,
          "description": data.system.description,
          "security-sensitivity-level": data.system.impactLevel
        },
        "control-implementation": {
          "description": "Control implementation for the system",
          "implemented-requirements": data.systemControls.map((sc: SystemControl) => ({
            "uuid": crypto.randomUUID(),
            "control-id": sc.controlId,
            "description": sc.implementationText || "Implementation pending"
          }))
        }
      }
    };
    
    const content = JSON.stringify(oscal, null, 2);
    const buffer = Buffer.from(content, 'utf-8');
    
    return {
      content: buffer,
      format: 'oscal',
      filename: `SSP_${data.system.name.replace(/\s+/g, '_')}_OSCAL_${new Date().toISOString().split('T')[0]}.json`,
      metadata: {
        systemName: data.system.name,
        generatedDate: new Date(),
        totalControls: data.controls.length,
        implementedControls: data.systemControls.filter((sc: SystemControl) => 
          sc.status === 'implemented'
        ).length
      }
    };
  }
  
  // Section generation methods
  private generateTitlePage(data: any, request: SSPGenerationRequest): string {
    const org = request.templateOptions?.organization || 'Organization';
    const classification = request.templateOptions?.classification || 'UNCLASSIFIED';
    
    return `
${classification}

SYSTEM SECURITY PLAN
for
${data.system.name}

${org}

Version: ${request.templateOptions?.version || '1.0'}
Date: ${request.templateOptions?.date || new Date().toLocaleDateString()}

Prepared By: ${request.templateOptions?.preparedBy || 'System Owner'}
Reviewed By: ${request.templateOptions?.reviewedBy || 'ISSO'}
Approved By: ${request.templateOptions?.approvedBy || 'Authorizing Official'}

${classification}
    `.trim();
  }
  
  private async generateExecutiveSummary(data: any, request: SSPGenerationRequest): Promise<string> {
    const implementedCount = data.systemControls.filter((sc: SystemControl) => 
      sc.status === 'implemented'
    ).length;
    
    const partialCount = data.systemControls.filter((sc: SystemControl) => 
      sc.status === 'partial'
    ).length;
    
    const prompt = `Generate an executive summary for a System Security Plan with the following details:

System: ${data.system.name}
Category: ${data.system.category}
Impact Level: ${data.system.impactLevel}
Total Controls: ${data.controls.length}
Implemented Controls: ${implementedCount}
Partially Implemented: ${partialCount}
Open Findings: ${data.findings.length}

The executive summary should be 2-3 paragraphs, highlighting:
1. System purpose and criticality
2. Current security posture
3. Key risks and mitigations
4. Compliance status`;

    const response = await modelRouter.generateText([{ role: 'user', content: prompt }], {
      maxTokens: 1000,
      temperature: 0.3
    });
    
    return response.content;
  }
  
  private async generateSystemOverview(data: any, request: SSPGenerationRequest): Promise<string> {
    let overview = `
## System Information

**System Name:** ${data.system.name}
**System Category:** ${data.system.category}
**Impact Level:** ${data.system.impactLevel}
**System Owner:** ${data.system.systemOwner || 'TBD'}

## System Description

${data.system.description || 'No description provided.'}

## System Boundary

The system boundary encompasses all components, interfaces, and data flows that comprise the ${data.system.name} information system.

## Responsible Parties

- **System Owner:** ${data.system.systemOwner || 'TBD'}
- **Information System Security Officer (ISSO):** ${request.templateOptions?.reviewedBy || 'TBD'}
- **Authorizing Official (AO):** ${request.templateOptions?.approvedBy || 'TBD'}
`;
    
    return overview;
  }
  
  private async generateSystemArchitecture(data: any): Promise<string> {
    const diagrams = data.artifacts.filter((a: Artifact) => 
      a.type === 'architecture_diagram'
    );
    
    let section = '## Architecture Overview\n\n';
    
    if (diagrams.length > 0) {
      section += 'The following architecture diagrams illustrate the system components and data flows:\n\n';
      
      diagrams.forEach((d: Artifact, i: number) => {
        section += `**Figure ${i + 1}:** ${d.title || d.name}\n`;
        section += `Description: ${d.description || 'See attached diagram'}\n\n`;
      });
    } else {
      section += 'Architecture diagrams are pending and will be added in the next revision.\n\n';
    }
    
    return section;
  }
  
  private async generateControlImplementation(data: any): Promise<string> {
    const stats = this.calculateControlStats(data);
    
    return `
This section describes how security controls are implemented within the ${data.system.name} system.

## Implementation Summary

- **Total Controls:** ${stats.total}
- **Implemented:** ${stats.implemented} (${stats.implementedPercent}%)
- **Partially Implemented:** ${stats.partial} (${stats.partialPercent}%)
- **Not Implemented:** ${stats.notImplemented} (${stats.notImplementedPercent}%)

## Control Families

The following control families are implemented within the system:

${stats.families.map((f: any) => `- **${f.family}**: ${f.count} controls`).join('\n')}
`;
  }
  
  private async generateFamilyNarratives(
    family: string, 
    controls: any[], 
    data: any
  ): Promise<string> {
    let content = '';
    
    for (const control of controls) {
      const systemControl = data.systemControls.find((sc: SystemControl) => 
        sc.controlId === control.id
      );
      
      content += `### ${control.id} - ${control.title}\n\n`;
      content += `**Control Description:** ${control.description}\n\n`;
      content += `**Implementation Status:** ${this.formatStatus(systemControl?.status)}\n\n`;
      
      if (systemControl?.implementationText) {
        content += `**Implementation:**\n${systemControl.implementationText}\n\n`;
      } else {
        content += `**Implementation:** Implementation narrative pending.\n\n`;
      }
      
      // Add evidence references
      const controlEvidence = data.evidence.filter((e: Evidence) => 
        e.controlId === control.id
      );
      
      if (controlEvidence.length > 0) {
        content += `**Supporting Evidence:**\n`;
        controlEvidence.forEach((e: Evidence) => {
          content += `- ${e.type}: ${e.description || 'See artifact'}\n`;
        });
        content += '\n';
      }
    }
    
    return content;
  }
  
  private async generateRiskAssessment(data: any): Promise<string> {
    const findingsByStatus = this.groupFindingsBySeverity(data.findings);
    
    let content = '## Assessment Results\n\n';
    content += `Last Assessment: ${data.assessments[0]?.createdAt || 'No assessments performed'}\n\n`;
    
    content += '## Finding Summary\n\n';
    content += `- **Critical:** ${findingsByStatus.critical || 0}\n`;
    content += `- **High:** ${findingsByStatus.high || 0}\n`;
    content += `- **Medium:** ${findingsByStatus.medium || 0}\n`;
    content += `- **Low:** ${findingsByStatus.low || 0}\n\n`;
    
    if (data.findings.length > 0) {
      content += '## Open Findings\n\n';
      
      ['critical', 'high', 'medium', 'low'].forEach(severity => {
        const findings = data.findings.filter((f: Finding) => f.severity === severity);
        if (findings.length > 0) {
          content += `### ${severity.toUpperCase()} Severity\n\n`;
          findings.forEach((f: Finding) => {
            content += `**${f.stigRuleId || f.id}:** ${f.title}\n`;
            content += `Description: ${f.description}\n\n`;
          });
        }
      });
    }
    
    return content;
  }
  
  private async generateEvidenceSection(data: any): Promise<string> {
    let content = '## Evidence Inventory\n\n';
    
    const evidenceByType = this.groupEvidenceByType(data.evidence);
    
    Object.entries(evidenceByType).forEach(([type, items]) => {
      content += `### ${this.formatEvidenceType(type)}\n\n`;
      (items as Evidence[]).forEach(item => {
        content += `- **${item.title || item.type}**: ${item.description || 'No description'}\n`;
      });
      content += '\n';
    });
    
    content += '## Artifact Repository\n\n';
    content += `Total Artifacts: ${data.artifacts.length}\n\n`;
    
    const artifactsByType = this.groupArtifactsByType(data.artifacts);
    Object.entries(artifactsByType).forEach(([type, items]) => {
      content += `- **${this.formatArtifactType(type)}**: ${(items as any[]).length} files\n`;
    });
    
    return content;
  }
  
  private async generateComplianceSummary(data: any): Promise<string> {
    const stats = this.calculateControlStats(data);
    
    return `
## Overall Compliance Status

The ${data.system.name} system has implemented ${stats.implementedPercent}% of required security controls.

## Compliance Metrics

- **Fully Compliant Controls:** ${stats.implemented}
- **Partially Compliant Controls:** ${stats.partial}  
- **Non-Compliant Controls:** ${stats.notImplemented}
- **Evidence Coverage:** ${this.calculateEvidenceCoverage(data)}%

## Recommendations

${await this.generateRecommendations(data)}
`;
  }
  
  private generateAppendices(data: any): string {
    return `
## Appendix A - Acronyms

- ATO: Authority to Operate
- FIPS: Federal Information Processing Standards
- ISSO: Information System Security Officer
- NIST: National Institute of Standards and Technology
- POA&M: Plan of Action and Milestones
- SSP: System Security Plan

## Appendix B - References

- NIST SP 800-53 Rev. 5: Security and Privacy Controls
- NIST SP 800-37 Rev. 2: Risk Management Framework
- NIST SP 800-18 Rev. 1: Guide for Developing Security Plans
`;
  }
  
  // Helper methods
  private groupControlsByFamily(controls: Control[], systemControls: SystemControl[]): Record<string, Control[]> {
    const families: Record<string, Control[]> = {};
    
    controls.forEach(control => {
      if (!families[control.family]) {
        families[control.family] = [];
      }
      families[control.family].push(control);
    });
    
    // Sort controls within each family
    Object.values(families).forEach(familyControls => {
      familyControls.sort((a, b) => a.id.localeCompare(b.id));
    });
    
    return families;
  }
  
  private calculateControlStats(data: any) {
    const total = data.systemControls.length;
    const implemented = data.systemControls.filter((sc: SystemControl) => 
      sc.status === 'implemented'
    ).length;
    const partial = data.systemControls.filter((sc: SystemControl) => 
      sc.status === 'partial'
    ).length;
    const notImplemented = total - implemented - partial;
    
    const families = new Map<string, number>();
    data.controls.forEach((c: Control) => {
      families.set(c.family, (families.get(c.family) || 0) + 1);
    });
    
    return {
      total,
      implemented,
      partial,
      notImplemented,
      implementedPercent: Math.round((implemented / total) * 100),
      partialPercent: Math.round((partial / total) * 100),
      notImplementedPercent: Math.round((notImplemented / total) * 100),
      families: Array.from(families.entries()).map(([family, count]) => ({ family, count }))
    };
  }
  
  private groupFindingsBySeverity(findings: Finding[]): Record<string, number> {
    return findings.reduce((acc, finding) => {
      acc[finding.severity] = (acc[finding.severity] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }
  
  private groupEvidenceByType(evidence: Evidence[]): Record<string, Evidence[]> {
    return evidence.reduce((acc, item) => {
      if (!acc[item.type]) acc[item.type] = [];
      acc[item.type].push(item);
      return acc;
    }, {} as Record<string, Evidence[]>);
  }
  
  private groupArtifactsByType(artifacts: Artifact[]): Record<string, Artifact[]> {
    return artifacts.reduce((acc, item) => {
      if (!acc[item.type]) acc[item.type] = [];
      acc[item.type].push(item);
      return acc;
    }, {} as Record<string, Artifact[]>);
  }
  
  private formatStatus(status?: string): string {
    if (!status) return 'Not Assessed';
    return status.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }
  
  private formatEvidenceType(type: string): string {
    return type.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }
  
  private formatArtifactType(type: string): string {
    return type.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }
  
  private calculateEvidenceCoverage(data: any): number {
    const controlsWithEvidence = new Set(data.evidence.map((e: Evidence) => e.controlId));
    return Math.round((controlsWithEvidence.size / data.controls.length) * 100);
  }
  
  private async generateRecommendations(data: any): Promise<string> {
    const notImplemented = data.systemControls.filter((sc: SystemControl) => 
      sc.status !== 'implemented'
    ).length;
    
    const criticalFindings = data.findings.filter((f: Finding) => 
      f.severity === 'critical'
    ).length;
    
    const prompt = `Generate 3-5 specific recommendations for improving the security posture of a system with:
- ${notImplemented} controls not fully implemented
- ${criticalFindings} critical findings
- ${data.findings.length} total findings

Focus on actionable steps to achieve ATO.`;

    const response = await modelRouter.generateText([{ role: 'user', content: prompt }], {
      maxTokens: 500,
      temperature: 0.3
    });
    
    return response.content;
  }
  
  private getFamilyName(family: string): string {
    const familyNames: Record<string, string> = {
      'AC': 'Access Control',
      'AT': 'Awareness and Training',
      'AU': 'Audit and Accountability',
      'CA': 'Assessment, Authorization, and Monitoring',
      'CM': 'Configuration Management',
      'CP': 'Contingency Planning',
      'IA': 'Identification and Authentication',
      'IR': 'Incident Response',
      'MA': 'Maintenance',
      'MP': 'Media Protection',
      'PE': 'Physical and Environmental Protection',
      'PL': 'Planning',
      'PS': 'Personnel Security',
      'RA': 'Risk Assessment',
      'SA': 'System and Services Acquisition',
      'SC': 'System and Communications Protection',
      'SI': 'System and Information Integrity',
      'SR': 'Supply Chain Risk Management'
    };
    
    return familyNames[family] || family;
  }
}

// Export singleton instance
export const sspGenerationService = new SSPGenerationService();
