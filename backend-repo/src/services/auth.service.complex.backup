import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { eq, and, or, gte, lt, sql } from 'drizzle-orm';
import { db } from '../db';
import { users, systems } from "../schema";

// ============================================================================
// AUTHENTICATION SERVICE
// ============================================================================

export interface AuthResult {
  success: boolean;
  user?: User;
  session?: UserSession;
  error?: string;
  requiresMFA?: boolean;
  mfaChallenge?: string;
}

export interface SessionInfo {
  userId: string;
  sessionId: string;
  role: UserRoleType;
  permissions: PermissionType[];
  systems: string[];
  expiresAt: Date;
}

export interface AuthContext {
  user: User;
  session: UserSession;
  role: UserRoleType;
  permissions: PermissionType[];
  systems: string[];
}

export class AuthenticationService {
  private readonly jwtSecret: string;
  private readonly sessionExpiry: number;
  private readonly refreshExpiry: number;
  private readonly maxFailedAttempts: number;
  private readonly lockoutDuration: number;

  constructor() {
    this.jwtSecret = process.env.JWT_SECRET || 'change-me-in-production';
    this.sessionExpiry = parseInt(process.env.SESSION_EXPIRY || '3600') * 1000; // 1 hour default
    this.refreshExpiry = parseInt(process.env.REFRESH_EXPIRY || '604800') * 1000; // 7 days default
    this.maxFailedAttempts = parseInt(process.env.MAX_FAILED_ATTEMPTS || '5');
    this.lockoutDuration = parseInt(process.env.LOCKOUT_DURATION || '900') * 1000; // 15 minutes default
  }

  // ============================================================================
  // USER AUTHENTICATION
  // ============================================================================

  /**
   * Authenticate user with username/password
   */
  async authenticateUser(username: string, password: string, ipAddress?: string, userAgent?: string): Promise<AuthResult> {
    try {
      // Find user
      const user = await this.findUserByUsername(username);
      if (!user) {
        await this.logAuditEvent('login_failed', 'user', null, null, false, 'User not found', { username, ipAddress });
        return { success: false, error: 'Invalid credentials' };
      }

      // Check if account is locked
      if (user.isLocked) {
        if (user.lockedUntil && new Date() < user.lockedUntil) {
          await this.logAuditEvent('login_failed', 'user', user.id, null, false, 'Account locked', { username, ipAddress });
          return { success: false, error: 'Account is locked. Please try again later.' };
        } else {
          // Unlock account if lockout period has expired
          await this.unlockUser(user.id);
        }
      }

      // Check if account is active
      if (!user.isActive) {
        await this.logAuditEvent('login_failed', 'user', user.id, null, false, 'Account inactive', { username, ipAddress });
        return { success: false, error: 'Account is inactive' };
      }

      // Verify password
      if (!user.passwordHash || !await bcrypt.compare(password, user.passwordHash)) {
        await this.handleFailedLogin(user.id, ipAddress);
        return { success: false, error: 'Invalid credentials' };
      }

      // Check if MFA is required
      const mfaMethods = await this.getUserMFAMethods(user.id);
      if (mfaMethods.length > 0) {
        const challenge = await this.createMFAChallenge(user.id);
        await this.logAuditEvent('mfa_required', 'user', user.id, null, true, null, { username, ipAddress });
        return { 
          success: false, 
          requiresMFA: true, 
          mfaChallenge: challenge,
          user 
        };
      }

      // Create session
      const session = await this.createUserSession(user.id, ipAddress, userAgent);
      await this.updateLastLogin(user.id);
      await this.resetFailedAttempts(user.id);

      await this.logAuditEvent('login_success', 'user', user.id, session.id, true, null, { username, ipAddress });

      return { success: true, user, session };
    } catch (error) {
      console.error('Authentication error:', error);
      return { success: false, error: 'Authentication failed' };
    }
  }

  /**
   * Authenticate with MFA
   */
  async authenticateWithMFA(userId: string, mfaCode: string, challenge: string): Promise<AuthResult> {
    try {
      // Verify MFA challenge
      const isValidChallenge = await this.verifyMFAChallenge(userId, challenge);
      if (!isValidChallenge) {
        return { success: false, error: 'Invalid MFA challenge' };
      }

      // Verify MFA code
      const isValidCode = await this.verifyMFACode(userId, mfaCode);
      if (!isValidCode) {
        await this.logAuditEvent('mfa_failed', 'user', userId, null, false, 'Invalid MFA code');
        return { success: false, error: 'Invalid MFA code' };
      }

      // Get user
      const user = await this.findUserById(userId);
      if (!user) {
        return { success: false, error: 'User not found' };
      }

      // Create session
      const session = await this.createUserSession(userId);
      await this.updateLastLogin(userId);
      await this.logAuditEvent('mfa_success', 'user', userId, session.id, true, null);

      return { success: true, user, session };
    } catch (error) {
      console.error('MFA authentication error:', error);
      return { success: false, error: 'MFA authentication failed' };
    }
  }

  /**
   * Authenticate with API key
   */
  async authenticateWithApiKey(apiKey: string): Promise<AuthResult> {
    try {
      const keyHash = crypto.createHash('sha256').update(apiKey).digest('hex');
      
      const apiKeyRecord = await db
        .select()
        .from(apiKeys)
        .where(and(
          eq(apiKeys.keyHash, keyHash),
          eq(apiKeys.isActive, true),
          or(
            eq(apiKeys.expiresAt, null),
            gte(apiKeys.expiresAt, new Date())
          )
        ))
        .limit(1);

      if (apiKeyRecord.length === 0) {
        await this.logAuditEvent('api_auth_failed', 'api_key', null, null, false, 'Invalid API key');
        return { success: false, error: 'Invalid API key' };
      }

      const key = apiKeyRecord[0];
      
      // Update last used
      await db
        .update(apiKeys)
        .set({ lastUsedAt: new Date() })
        .where(eq(apiKeys.id, key.id));

      // Get user if associated
      let user: User | undefined;
      if (key.userId) {
        user = await this.findUserById(key.userId);
      }

      await this.logAuditEvent('api_auth_success', 'api_key', key.userId, null, true, null, { keyName: key.name });

      return { success: true, user, apiKey: key };
    } catch (error) {
      console.error('API key authentication error:', error);
      return { success: false, error: 'API key authentication failed' };
    }
  }

  // ============================================================================
  // SESSION MANAGEMENT
  // ============================================================================

  /**
   * Validate session and get auth context
   */
  async validateSession(sessionToken: string): Promise<AuthContext | null> {
    try {
      const session = await db
        .select()
        .from(userSessions)
        .where(and(
          eq(userSessions.sessionToken, sessionToken),
          eq(userSessions.isActive, true),
          gte(userSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return null;
      }

      const sessionRecord = session[0];
      const user = await this.findUserById(sessionRecord.userId);
      if (!user || !user.isActive) {
        return null;
      }

      // Update last activity
      await db
        .update(userSessions)
        .set({ lastActivityAt: new Date() })
        .where(eq(userSessions.id, sessionRecord.id));

      // Get user permissions
      const { role, permissions, systems } = await this.getUserPermissions(user.id);

      return {
        user,
        session: sessionRecord,
        role,
        permissions,
        systems
      };
    } catch (error) {
      console.error('Session validation error:', error);
      return null;
    }
  }

  /**
   * Create user session
   */
  private async createUserSession(userId: string, ipAddress?: string, userAgent?: string): Promise<UserSession> {
    const sessionToken = crypto.randomBytes(32).toString('hex');
    const refreshToken = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + this.sessionExpiry);
    const refreshExpiresAt = new Date(Date.now() + this.refreshExpiry);

    const sessionData: InsertUserSession = {
      userId,
      sessionToken,
      refreshToken,
      userAgent,
      ipAddress,
      expiresAt,
      refreshExpiresAt,
      isActive: true
    };

    const [session] = await db.insert(userSessions).values(sessionData).returning();
    return session;
  }

  /**
   * Refresh session
   */
  async refreshSession(refreshToken: string): Promise<AuthResult> {
    try {
      const session = await db
        .select()
        .from(userSessions)
        .where(and(
          eq(userSessions.refreshToken, refreshToken),
          eq(userSessions.isActive, true),
          gte(userSessions.refreshExpiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return { success: false, error: 'Invalid refresh token' };
      }

      const sessionRecord = session[0];
      const user = await this.findUserById(sessionRecord.userId);
      if (!user || !user.isActive) {
        return { success: false, error: 'User not found or inactive' };
      }

      // Create new session
      const newSession = await this.createUserSession(user.id, sessionRecord.ipAddress, sessionRecord.userAgent);
      
      // Deactivate old session
      await db
        .update(userSessions)
        .set({ isActive: false })
        .where(eq(userSessions.id, sessionRecord.id));

      return { success: true, user, session: newSession };
    } catch (error) {
      console.error('Session refresh error:', error);
      return { success: false, error: 'Session refresh failed' };
    }
  }

  /**
   * Logout user
   */
  async logout(sessionToken: string): Promise<boolean> {
    try {
      await db
        .update(userSessions)
        .set({ isActive: false })
        .where(eq(userSessions.sessionToken, sessionToken));

      return true;
    } catch (error) {
      console.error('Logout error:', error);
      return false;
    }
  }

  // ============================================================================
  // USER MANAGEMENT
  // ============================================================================

  /**
   * Create new user
   */
  async createUser(userData: InsertUser): Promise<AuthResult> {
    try {
      // Hash password if provided
      if (userData.password) {
        const salt = await bcrypt.genSalt(12);
        userData.passwordHash = await bcrypt.hash(userData.password, salt);
        userData.salt = salt;
        delete userData.password;
      }

      const [user] = await db.insert(users).values(userData).returning();
      
      // Assign default role if specified
      if (userData.role) {
        await this.assignUserRole(user.id, userData.role);
      }

      await this.logAuditEvent('user_created', 'user', user.id, null, true, null, { username: user.username });

      return { success: true, user };
    } catch (error) {
      console.error('User creation error:', error);
      return { success: false, error: 'User creation failed' };
    }
  }

  /**
   * Find user by username
   */
  private async findUserByUsername(username: string): Promise<User | null> {
    const result = await db
      .select()
      .from(users)
      .where(eq(users.username, username))
      .limit(1);

    return result[0] || null;
  }

  /**
   * Find user by ID
   */
  private async findUserById(userId: string): Promise<User | null> {
    const result = await db
      .select()
      .from(users)
      .where(eq(users.id, userId))
      .limit(1);

    return result[0] || null;
  }

  // ============================================================================
  // PERMISSION MANAGEMENT
  // ============================================================================

  /**
   * Get user permissions
   */
  async getUserPermissions(userId: string): Promise<{ role: UserRoleType; permissions: PermissionType[]; systems: string[] }> {
    // Get user roles
    const userRolesResult = await db
      .select()
      .from(userRoles)
      .where(and(
        eq(userRoles.userId, userId),
        eq(userRoles.isActive, true),
        or(
          eq(userRoles.expiresAt, null),
          gte(userRoles.expiresAt, new Date())
        )
      ));

    const roles = userRolesResult.map(ur => ur.role as UserRoleType);
    const primaryRole = roles[0] || 'viewer';

    // Get permissions for roles
    const permissions = await db
      .select()
      .from(rolePermissions)
      .where(eq(rolePermissions.role, primaryRole));

    const permissionList = permissions.map(p => p.permission as PermissionType);

    // Get system access
    const systemAccess = userRolesResult
      .filter(ur => ur.systemId)
      .map(ur => ur.systemId!);

    return {
      role: primaryRole,
      permissions: permissionList,
      systems: systemAccess
    };
  }

  /**
   * Check if user has permission
   */
  async hasPermission(userId: string, permission: PermissionType, resourceId?: string): Promise<boolean> {
    const { permissions, systems } = await this.getUserPermissions(userId);
    
    // Check if user has the permission
    if (!permissions.includes(permission)) {
      return false;
    }

    // If resource-specific, check system access
    if (resourceId && !systems.includes('*') && !systems.includes(resourceId)) {
      return false;
    }

    return true;
  }

  /**
   * Assign role to user
   */
  async assignUserRole(userId: string, role: UserRoleType, systemId?: string, grantedBy?: string): Promise<boolean> {
    try {
      await db.insert(userRoles).values({
        userId,
        role,
        systemId,
        grantedBy,
        isActive: true
      });

      await this.logAuditEvent('role_assigned', 'user_role', userId, null, true, null, { role, systemId, grantedBy });
      return true;
    } catch (error) {
      console.error('Role assignment error:', error);
      return false;
    }
  }

  // ============================================================================
  // MFA MANAGEMENT
  // ============================================================================

  /**
   * Get user MFA methods
   */
  private async getUserMFAMethods(userId: string) {
    return await db
      .select()
      .from(userMFA)
      .where(and(
        eq(userMFA.userId, userId),
        eq(userMFA.isEnabled, true)
      ));
  }

  /**
   * Create MFA challenge
   */
  private async createMFAChallenge(userId: string): Promise<string> {
    const challenge = crypto.randomBytes(32).toString('hex');
    // Store challenge in memory or Redis with expiration
    // For now, return the challenge (in production, store securely)
    return challenge;
  }

  /**
   * Verify MFA challenge
   */
  private async verifyMFAChallenge(userId: string, challenge: string): Promise<boolean> {
    // In production, verify against stored challenge
    return true; // Simplified for now
  }

  /**
   * Verify MFA code
   */
  private async verifyMFACode(userId: string, code: string): Promise<boolean> {
    // Implement TOTP verification
    // For now, accept any 6-digit code
    return /^\d{6}$/.test(code);
  }

  // ============================================================================
  // SECURITY HELPERS
  // ============================================================================

  /**
   * Handle failed login attempt
   */
  private async handleFailedLogin(userId: string, ipAddress?: string): Promise<void> {
    await db
      .update(users)
      .set({
        failedLoginAttempts: sql`failed_login_attempts + 1`,
        lastActivityAt: new Date()
      })
      .where(eq(users.id, userId));

    // Check if account should be locked
    const user = await this.findUserById(userId);
    if (user && user.failedLoginAttempts >= this.maxFailedAttempts) {
      await this.lockUser(userId);
    }

    await this.logAuditEvent('login_failed', 'user', userId, null, false, 'Invalid password', { ipAddress });
  }

  /**
   * Lock user account
   */
  private async lockUser(userId: string): Promise<void> {
    const lockedUntil = new Date(Date.now() + this.lockoutDuration);
    await db
      .update(users)
      .set({
        isLocked: true,
        lockedUntil
      })
      .where(eq(users.id, userId));

    await this.logAuditEvent('account_locked', 'user', userId, null, true, null, { lockedUntil });
  }

  /**
   * Unlock user account
   */
  private async unlockUser(userId: string): Promise<void> {
    await db
      .update(users)
      .set({
        isLocked: false,
        lockedUntil: null,
        failedLoginAttempts: 0
      })
      .where(eq(users.id, userId));
  }

  /**
   * Reset failed login attempts
   */
  private async resetFailedAttempts(userId: string): Promise<void> {
    await db
      .update(users)
      .set({ failedLoginAttempts: 0 })
      .where(eq(users.id, userId));
  }

  /**
   * Update last login
   */
  private async updateLastLogin(userId: string): Promise<void> {
    await db
      .update(users)
      .set({
        lastLoginAt: new Date(),
        lastActivityAt: new Date()
      })
      .where(eq(users.id, userId));
  }

  /**
   * Log audit event
   */
  private async logAuditEvent(
    eventType: string,
    resource: string,
    userId: string | null,
    sessionId: string | null,
    success: boolean,
    errorMessage?: string | null,
    metadata?: any
  ): Promise<void> {
    try {
      const auditData: InsertAuditLog = {
        eventType,
        action: 'authenticate',
        resource,
        resourceId: userId,
        userId,
        sessionId,
        success,
        errorMessage,
        metadata
      };

      await db.insert(auditLog).values(auditData);
    } catch (error) {
      console.error('Audit logging error:', error);
    }
  }

  // ============================================================================
  // SIMPLE AUTH METHODS (for backward compatibility with controllers)
  // ============================================================================

  /**
   * Simple register method for auth controller
   */
  async register(data: { username: string; password: string }) {
    // Check if user exists
    const [existingUser] = await db
      .select()
      .from(users)
      .where(eq(users.username, data.username))
      .limit(1);

    if (existingUser) {
      throw new Error('Username already exists');
    }

    // Hash password
    const passwordHash = await bcrypt.hash(data.password, 10);

    // Create user with only fields that exist in our schema
    const [user] = await db.insert(users).values({
      username: data.username,
      passwordHash,
      role: 'user',
    }).returning();

    // Generate tokens
    const accessToken = this.generateAccessToken(user.id, user.username);
    const refreshToken = this.generateRefreshToken(user.id);

    return {
      user: {
        id: user.id,
        username: user.username,
        email: `${user.username}@example.com`, // Virtual email for compatibility
      },
      accessToken,
      refreshToken,
    };
  }

  /**
   * Simple login method for auth controller
   */
  async login(data: { username: string; password: string }) {
    // Find user
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.username, data.username))
      .limit(1);

    if (!user) {
      throw new Error('Invalid credentials');
    }

    // Verify password
    const isValid = await bcrypt.compare(data.password, user.passwordHash);
    if (!isValid) {
      throw new Error('Invalid credentials');
    }

    // Generate tokens
    const accessToken = this.generateAccessToken(user.id, user.username);
    const refreshToken = this.generateRefreshToken(user.id);

    return {
      user: {
        id: user.id,
        username: user.username,
        email: `${user.username}@example.com`, // Virtual email for compatibility
      },
      accessToken,
      refreshToken,
    };
  }

  /**
   * Refresh access token
   */
  async refreshAccessToken(refreshToken: string) {
    try {
      const payload = jwt.verify(refreshToken, this.jwtSecret) as { userId: string; type: string };
      
      if (payload.type !== 'refresh') {
        throw new Error('Invalid token type');
      }

      const user = await this.findUserById(payload.userId);
      if (!user) {
        throw new Error('User not found');
      }

      const accessToken = this.generateAccessToken(user.id, user.username);
      
      return { accessToken };
    } catch (error) {
      throw new Error('Invalid refresh token');
    }
  }

  /**
   * Get current user info
   */
  async getCurrentUser(userId: string) {
    const user = await this.findUserById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    return {
      id: user.id,
      username: user.username,
      email: user.email || '',
    };
  }

  /**
   * Generate access token
   */
  private generateAccessToken(userId: string, username: string): string {
    return jwt.sign(
      { userId, username, type: 'access' },
      this.jwtSecret,
      { expiresIn: '15m' }
    );
  }

  /**
   * Generate refresh token
   */
  private generateRefreshToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'refresh' },
      this.jwtSecret,
      { expiresIn: '7d' }
    );
  }
}

// Export singleton instance
export const authService = new AuthenticationService();
