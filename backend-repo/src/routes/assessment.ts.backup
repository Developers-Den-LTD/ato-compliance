// Assessment API Routes
// REST endpoints for triggering and managing compliance assessments

import { Router } from 'express';
import { z } from 'zod';
import { storage } from '../storage';
import { assessmentEngine, type AssessmentOptions } from '../services/assessment-engine';

const router = Router();

// Request schemas for validation
const AssessmentRequestSchema = z.object({
  assessmentMode: z.enum(['automated', 'manual', 'hybrid']).default('automated'),
  includeInformationalFindings: z.boolean().default(false),
  generatePoamItems: z.boolean().default(true),
  generateEvidence: z.boolean().default(true),
  updateControlStatus: z.boolean().default(true),
  riskTolerance: z.enum(['low', 'medium', 'high']).default('medium'),
  userId: z.string().optional()
});

const ControlStatusUpdateSchema = z.object({
  status: z.enum(['compliant', 'non-compliant', 'in-progress', 'not-assessed']),
  implementationStatus: z.enum(['implemented', 'partially_implemented', 'planned', 'alternative_implementation', 'not_applicable', 'not_implemented']).optional(),
  assessorNotes: z.string().optional(),
  evidence: z.string().optional()
});

const BulkAssessmentSchema = z.object({
  systemIds: z.array(z.string()).min(1).max(10), // Limit bulk assessments
  assessmentOptions: AssessmentRequestSchema.optional()
});

// ========== SYSTEM ASSESSMENT ENDPOINTS ==========

/**
 * POST /api/assessment/systems/:systemId/assess
 * Trigger comprehensive system assessment
 */
router.post('/systems/:systemId/assess', async (req, res) => {
  try {
    const { systemId } = req.params;
    
    // Validate system exists
    const system = await storage.getSystem(systemId);
    if (!system) {
      return res.status(404).json({ error: 'System not found' });
    }

    // Validate request body
    const options = AssessmentRequestSchema.parse(req.body);

    // Check for existing running assessment
    const activeAssessments = assessmentEngine.getActiveAssessments();
    const existingAssessment = activeAssessments.find(a => 
      a.systemId === systemId && a.status === 'running'
    );

    if (existingAssessment) {
      return res.status(409).json({ 
        error: 'Assessment already in progress for this system',
        assessmentId: existingAssessment.assessmentId,
        progress: existingAssessment.progress
      });
    }

    // Start assessment
    const assessmentResult = await assessmentEngine.assessSystem(systemId, options as AssessmentOptions);

    res.status(202).json({
      message: 'Assessment started',
      assessmentId: assessmentResult.assessmentId,
      systemId,
      status: assessmentResult.status,
      progress: assessmentResult.progress,
      startTime: assessmentResult.startTime,
      estimatedCompletion: new Date(Date.now() + 300000) // 5 minutes estimate
    });

  } catch (error) {
    console.error('Error starting assessment:', error);
    
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Invalid request data',
        details: error.errors
      });
    }
    
    res.status(500).json({ error: 'Failed to start assessment' });
  }
});

/**
 * GET /api/assessment/systems/:systemId/status
 * Get current assessment status for a system
 */
router.get('/systems/:systemId/status', async (req, res) => {
  try {
    const { systemId } = req.params;
    
    // First check for active (running) assessments
    const activeAssessments = assessmentEngine.getActiveAssessments();
    const systemAssessments = activeAssessments.filter(a => a.systemId === systemId);
    
    let latestAssessment = systemAssessments.sort((a, b) => 
      b.startTime.getTime() - a.startTime.getTime()
    )[0];

    // If no active assessment, check database for the latest assessment
    if (!latestAssessment) {
      const dbAssessment = await storage.getLatestAssessmentBySystem(systemId);
      if (dbAssessment) {
        // Convert database assessment to response format
        return res.json({
          assessmentId: dbAssessment.assessmentId,
          systemId,
          status: dbAssessment.status,
          progress: dbAssessment.progress || 0,
          startTime: dbAssessment.startTime,
          endTime: dbAssessment.endTime,
          currentStep: dbAssessment.status === 'completed' ? 'Completed' : 
                      dbAssessment.status === 'failed' ? 'Failed' : 'Processing...',
          errors: dbAssessment.errors || []
        });
      } else {
        return res.status(404).json({ 
          error: 'No assessments found for this system',
          systemId 
        });
      }
    }

    // Return active assessment status
    res.json({
      assessmentId: latestAssessment.assessmentId,
      systemId,
      status: latestAssessment.status,
      progress: latestAssessment.progress,
      startTime: latestAssessment.startTime,
      endTime: latestAssessment.endTime,
      currentStep: latestAssessment.progress < 100 ? 'Processing...' : 'Completed',
      errors: latestAssessment.errors
    });

  } catch (error) {
    console.error('Error getting assessment status:', error);
    res.status(500).json({ error: 'Failed to get assessment status' });
  }
});

/**
 * GET /api/assessment/systems/:systemId/results
 * Get complete assessment results for a system
 */
router.get('/systems/:systemId/results', async (req, res) => {
  try {
    const { systemId } = req.params;
    const { assessmentId, includeDetails = 'true' } = req.query;
    
    let assessment;
    
    if (assessmentId && typeof assessmentId === 'string') {
      // Get specific assessment by ID
      assessment = assessmentEngine.getAssessmentStatus(assessmentId);
      if (!assessment || assessment.systemId !== systemId) {
        return res.status(404).json({ error: 'Assessment not found' });
      }
    } else {
      // Get latest assessment for system
      const activeAssessments = assessmentEngine.getActiveAssessments();
      const systemAssessments = activeAssessments.filter(a => a.systemId === systemId);
      
      if (systemAssessments.length === 0) {
        return res.status(404).json({ 
          error: 'No assessments found for this system',
          systemId 
        });
      }
      
      assessment = systemAssessments.sort((a, b) => 
        b.startTime.getTime() - a.startTime.getTime()
      )[0];
    }

    // Return summary or detailed results based on query parameter
    if (includeDetails === 'false') {
      res.json({
        assessmentId: assessment.assessmentId,
        systemId: assessment.systemId,
        status: assessment.status,
        summary: assessment.summary,
        findings: assessment.findings,
        stigCompliance: assessment.stigCompliance,
        lastUpdated: assessment.endTime || new Date()
      });
    } else {
      res.json(assessment);
    }

  } catch (error) {
    console.error('Error getting assessment results:', error);
    res.status(500).json({ error: 'Failed to get assessment results' });
  }
});

/**
 * GET /api/assessment/systems/:systemId/summary
 * Get assessment summary with key metrics
 */
router.get('/systems/:systemId/summary', async (req, res) => {
  try {
    const { systemId } = req.params;
    
    // Get system information
    const system = await storage.getSystem(systemId);
    if (!system) {
      return res.status(404).json({ error: 'System not found' });
    }

    // First check for active (running) assessments
    const activeAssessments = assessmentEngine.getActiveAssessments();
    const systemAssessments = activeAssessments.filter(a => a.systemId === systemId);
    let latestAssessment = systemAssessments.sort((a, b) => 
      b.startTime.getTime() - a.startTime.getTime()
    )[0];

    // If no active assessment, generate real-time summary from current data
    if (!latestAssessment) {
      // Get real-time data
      const [findings, documents, systemControls] = await Promise.all([
        storage.getFindingsBySystem(systemId),
        storage.getDocumentsBySystem(systemId),
        storage.getSystemControls(systemId)
      ]);
      
      // Calculate real metrics
      const totalControls = systemControls.length;
      const implementedControls = systemControls.filter(sc => sc.status === 'implemented').length;
      const nonCompliantControls = systemControls.filter(sc => sc.status === 'not_implemented').length;
      const compliancePercentage = totalControls > 0 ? Math.round((implementedControls / totalControls) * 100) : 0;
      
      // Calculate findings by severity
      const criticalFindings = findings.filter(f => f.severity === 'critical').length;
      const highFindings = findings.filter(f => f.severity === 'high').length;
      const mediumFindings = findings.filter(f => f.severity === 'medium').length;
      const lowFindings = findings.filter(f => f.severity === 'low').length;
      const openFindings = findings.filter(f => f.status === 'open').length;
      
      // Generate real-time assessment summary
      latestAssessment = {
        systemId,
        assessmentId: `realtime_${systemId}_${Date.now()}`,
        status: 'completed' as const,
        progress: 100,
        startTime: new Date(),
        endTime: new Date(),
        summary: {
          totalControls,
          compliantControls: implementedControls,
          nonCompliantControls,
          partiallyImplementedControls: systemControls.filter(sc => sc.status === 'partial').length,
          notAssessedControls: systemControls.filter(sc => sc.status === 'not_applicable').length,
          overallCompliancePercentage: compliancePercentage,
          riskScore: Math.max(0, 100 - compliancePercentage)
        },
        findings: {
          totalFindings: findings.length,
          criticalFindings,
          highFindings,
          mediumFindings,
          lowFindings,
          resolvedFindings: findings.length - openFindings
        },
        stigCompliance: {
            totalRules: 0,
            compliantRules: 0,
            nonCompliantRules: 0,
            notApplicableRules: 0,
            notReviewedRules: 0,
            compliancePercentage: 0
          },
          controlAssessments: [],
          poamItems: [],
          errors: []
        };
      }
    }

    if (!latestAssessment) {
      return res.status(404).json({ 
        error: 'No assessments found for this system. Please run an assessment first.',
        systemId 
      });
    }

    // Get additional metrics
    const [totalFindings, openFindings, controls] = await Promise.all([
      storage.getFindingsBySystem(systemId),
      storage.getFindingsBySystem(systemId).then(findings => 
        findings.filter(f => f.status === 'open')
      ),
      storage.getControls()
    ]);

    res.json({
      system: {
        id: system.id,
        name: system.name,
        category: system.category,
        impactLevel: system.impactLevel,
        complianceStatus: system.complianceStatus
      },
      assessment: {
        id: latestAssessment.assessmentId,
        status: latestAssessment.status,
        lastRun: latestAssessment.endTime || latestAssessment.startTime,
        overallCompliance: latestAssessment.summary.overallCompliancePercentage,
        riskScore: latestAssessment.summary.riskScore
      },
      metrics: {
        totalControls: latestAssessment.summary.totalControls,
        compliantControls: latestAssessment.summary.compliantControls,
        nonCompliantControls: latestAssessment.summary.nonCompliantControls,
        totalFindings: totalFindings.length,
        openFindings: openFindings.length,
        criticalFindings: latestAssessment.findings.criticalFindings,
        highFindings: latestAssessment.findings.highFindings,
        stigCompliance: latestAssessment.stigCompliance.stigCompliancePercentage
      },
      trends: {
        riskTrend: 'stable', // Could be enhanced with historical data
        complianceTrend: 'improving' // Could be enhanced with historical data
      }
    });

  } catch (error) {
    console.error('Error getting assessment summary:', error);
    res.status(500).json({ error: 'Failed to get assessment summary' });
  }
});

// ========== CONTROL ASSESSMENT ENDPOINTS ==========

/**
 * GET /api/assessment/controls/:controlId/status
 * Get assessment status for a specific control
 */
router.get('/controls/:controlId/status', async (req, res) => {
  try {
    const { controlId } = req.params;
    const { systemId } = req.query;
    
    // Validate control exists
    const control = await storage.getControl(controlId);
    if (!control) {
      return res.status(404).json({ error: 'Control not found' });
    }

    // Get evidence and findings for this control
    const [evidence, ccis] = await Promise.all([
      storage.getEvidenceByControl(controlId),
      storage.getCcisByControl(controlId)
    ]);

    // Filter by system if specified
    const systemEvidence = systemId ? 
      evidence.filter(e => e.systemId === systemId) : evidence;

    // Get related STIG rules via CCI mappings
    const stigRuleIds = new Set<string>();
    for (const cci of ccis) {
      const mappings = await storage.getStigRuleCcisByCci(cci.cci);
      mappings.forEach(mapping => stigRuleIds.add(mapping.stigRuleId));
    }

    const stigRules = await Promise.all(
      Array.from(stigRuleIds).map(id => storage.getStigRule(id))
    );
    const validStigRules = stigRules.filter(Boolean);

    // Calculate implementation status
    const satisfyingEvidence = systemEvidence.filter(e => e.status === 'satisfies').length;
    const partialEvidence = systemEvidence.filter(e => e.status === 'partially_satisfies').length;
    const nonSatisfyingEvidence = systemEvidence.filter(e => e.status === 'does_not_satisfy').length;

    let implementationStatus: string;
    if (satisfyingEvidence > 0 && nonSatisfyingEvidence === 0) {
      implementationStatus = 'implemented';
    } else if (satisfyingEvidence > 0 || partialEvidence > 0) {
      implementationStatus = 'partially_implemented';
    } else if (nonSatisfyingEvidence > 0) {
      implementationStatus = 'not_implemented';
    } else {
      implementationStatus = 'not_assessed';
    }

    res.json({
      controlId,
      title: control.title,
      family: control.family,
      status: control.status,
      implementationStatus,
      baseline: control.baseline,
      evidenceCount: systemEvidence.length,
      stigRulesMapped: validStigRules.length,
      ccisLinked: ccis.length,
      evidence: systemEvidence.map(e => ({
        id: e.id,
        type: e.type,
        status: e.status,
        description: e.description,
        createdAt: e.createdAt
      })),
      relatedStigRules: validStigRules.map(rule => ({
        id: rule!.id,
        title: rule!.title,
        severity: rule!.severity
      }))
    });

  } catch (error) {
    console.error('Error getting control status:', error);
    res.status(500).json({ error: 'Failed to get control status' });
  }
});

/**
 * POST /api/assessment/controls/:controlId/status
 * Update control assessment status
 */
router.post('/controls/:controlId/status', async (req, res) => {
  try {
    const { controlId } = req.params;
    const updates = ControlStatusUpdateSchema.parse(req.body);
    
    // Validate control exists
    const control = await storage.getControl(controlId);
    if (!control) {
      return res.status(404).json({ error: 'Control not found' });
    }

    // Note: Control status update would require schema modification
    // For now, we'll track status through evidence records
    const existingControl = await storage.getControl(controlId);
    const updatedControl = existingControl;

    if (!updatedControl) {
      return res.status(500).json({ error: 'Failed to update control' });
    }

    // Create evidence record if provided
    if (updates.evidence && req.body.systemId) {
      const evidenceStatus: 'satisfies' | 'partially_satisfies' | 'does_not_satisfy' | 'not_applicable' = 
        updates.status === 'compliant' ? 'satisfies' : 
        updates.status === 'in-progress' ? 'partially_satisfies' : 
        'does_not_satisfy';

      const evidenceData = {
        systemId: req.body.systemId,
        controlId,
        type: 'document' as const,
        description: updates.evidence,
        implementation: updates.evidence,
        assessorNotes: updates.assessorNotes || '',
        status: evidenceStatus
      };

      await storage.createEvidence(evidenceData);
    }

    res.json({
      message: 'Control status updated successfully',
      control: updatedControl,
      updates: updates
    });

  } catch (error) {
    console.error('Error updating control status:', error);
    
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Invalid request data',
        details: error.errors
      });
    }
    
    res.status(500).json({ error: 'Failed to update control status' });
  }
});

// ========== STIG ASSESSMENT ENDPOINTS ==========

/**
 * GET /api/assessment/stig/:stigId/checklist
 * Generate STIG/JSTIG checklist for assessment
 */
router.get('/stig/:stigId/checklist', async (req, res) => {
  try {
    const { stigId } = req.params;
    const { systemId, format = 'json', ruleType } = req.query;
    
    if (!systemId || typeof systemId !== 'string') {
      return res.status(400).json({ error: 'systemId query parameter is required' });
    }

    // Validate ruleType if provided
    let validatedRuleType: 'stig' | 'jstig' | undefined;
    if (ruleType && typeof ruleType === 'string') {
      if (ruleType !== 'stig' && ruleType !== 'jstig') {
        return res.status(400).json({ error: 'ruleType must be either "stig" or "jstig"' });
      }
      validatedRuleType = ruleType as 'stig' | 'jstig';
    }

    // Get STIG/JSTIG rules for this STIG ID
    const stigRules = await storage.getStigRulesByStigId(stigId, validatedRuleType);
    if (stigRules.length === 0) {
      const ruleTypeText = validatedRuleType ? validatedRuleType.toUpperCase() : 'STIG/JSTIG';
      return res.status(404).json({ error: `No ${ruleTypeText} rules found for this STIG ID` });
    }

    // Get findings for this system
    const systemFindings = await storage.getFindingsBySystem(systemId);
    
    // Build checklist items
    const checklistItems = stigRules.map(rule => {
      const relatedFindings = systemFindings.filter(f => f.stigRuleId === rule.id);
      const openFindings = relatedFindings.filter(f => f.status === 'open');
      
      let status: 'pass' | 'fail' | 'not_reviewed';
      let comments = '';
      
      if (relatedFindings.length === 0) {
        status = 'not_reviewed';
        comments = 'No findings identified - requires manual review';
      } else if (openFindings.length === 0) {
        status = 'pass';
        comments = `${relatedFindings.length} findings resolved`;
      } else {
        status = 'fail';
        comments = `${openFindings.length} open findings require remediation`;
      }

      return {
        ruleId: rule.id,
        ruleType: rule.ruleType || 'stig', // Ensure ruleType is always included
        title: rule.title,
        severity: rule.severity,
        description: rule.description,
        checkText: rule.checkText,
        fixText: rule.fixText,
        status,
        comments,
        findingsCount: relatedFindings.length,
        openFindingsCount: openFindings.length,
        lastAssessed: new Date().toISOString()
      };
    });

    // Calculate summary statistics
    const totalRules = checklistItems.length;
    const passedRules = checklistItems.filter(item => item.status === 'pass').length;
    const failedRules = checklistItems.filter(item => item.status === 'fail').length;
    const notReviewedRules = checklistItems.filter(item => item.status === 'not_reviewed').length;
    
    // Determine the rule type for display purposes
    const primaryRuleType = validatedRuleType || (stigRules.length > 0 ? stigRules[0].ruleType || 'stig' : 'stig');
    const ruleTypeDisplay = primaryRuleType.toUpperCase();
    
    const checklist = {
      stigId,
      systemId,
      ruleType: validatedRuleType, // Include the filtered rule type in response
      title: `${ruleTypeDisplay} Checklist for ${stigId}`,
      generatedAt: new Date().toISOString(),
      summary: {
        totalRules,
        passedRules,
        failedRules,
        notReviewedRules,
        compliancePercentage: Math.round((passedRules / totalRules) * 100),
        ruleType: primaryRuleType
      },
      items: checklistItems
    };

    // Save checklist to database
    const checklistRecord = await storage.createChecklist({
      systemId,
      stigId,
      stigName: stigId,
      title: checklist.title,
      content: checklist,
      items: checklistItems,
      findings: totalRules,
      compliant: passedRules,
      completionStatus: 'completed',
      generatedBy: 'ai_generated'
    });

    if (format === 'json') {
      res.json(checklist);
    } else {
      // Could add XML/CSV export formats here
      res.status(400).json({ error: 'Unsupported format. Use format=json' });
    }

  } catch (error) {
    console.error('Error generating STIG checklist:', error);
    res.status(500).json({ error: 'Failed to generate STIG checklist' });
  }
});

/**
 * GET /api/assessment/stig/rules/:ruleId/status
 * Get assessment status for a specific STIG rule
 */
router.get('/stig/rules/:ruleId/status', async (req, res) => {
  try {
    const { ruleId } = req.params;
    const { systemId } = req.query;
    
    // Get STIG rule
    const stigRule = await storage.getStigRule(ruleId);
    if (!stigRule) {
      return res.status(404).json({ error: 'STIG rule not found' });
    }

    // Get findings for this rule
    let findings = await storage.getFindings();
    findings = findings.filter(f => f.stigRuleId === ruleId);
    
    if (systemId && typeof systemId === 'string') {
      findings = findings.filter(f => f.systemId === systemId);
    }

    // Get CCI mappings
    const cciMappings = await storage.getStigRuleCcisByStigRule(ruleId);
    const ccis = await Promise.all(
      cciMappings.map(mapping => storage.getCci(mapping.cci))
    );
    const validCcis = ccis.filter(Boolean);

    // Determine compliance status
    const openFindings = findings.filter(f => f.status === 'open');
    const resolvedFindings = findings.filter(f => f.status === 'fixed' || f.status === 'accepted');
    
    let status: 'pass' | 'fail' | 'not_reviewed';
    if (findings.length === 0) {
      status = 'not_reviewed';
    } else if (openFindings.length === 0) {
      status = 'pass';
    } else {
      status = 'fail';
    }

    res.json({
      ruleId,
      ruleType: stigRule.ruleType || 'stig', // Include ruleType in response
      title: stigRule.title,
      severity: stigRule.severity,
      status,
      description: stigRule.description,
      checkText: stigRule.checkText,
      fixText: stigRule.fixText,
      findings: {
        total: findings.length,
        open: openFindings.length,
        resolved: resolvedFindings.length
      },
      ccis: validCcis.map(cci => ({
        cci: cci!.cci,
        definition: cci!.definition,
        controlId: cci!.controlId
      })),
      lastAssessed: findings.length > 0 ? 
        Math.max(...findings.map(f => new Date(f.createdAt!).getTime())) : null
    });

  } catch (error) {
    console.error('Error getting STIG rule status:', error);
    res.status(500).json({ error: 'Failed to get STIG rule status' });
  }
});

// ========== JSTIG ASSESSMENT ENDPOINTS ==========

/**
 * GET /api/assessment/jstig/:stigId/checklist
 * Generate JSTIG checklist for assessment (convenience endpoint)
 */
router.get('/jstig/:stigId/checklist', async (req, res) => {
  try {
    const { stigId } = req.params;
    const { systemId, format = 'json' } = req.query;
    
    if (!systemId || typeof systemId !== 'string') {
      return res.status(400).json({ error: 'systemId query parameter is required' });
    }

    // Get JSTIG rules for this STIG ID
    const jstigRules = await storage.getJstigRulesByStigId(stigId);
    if (jstigRules.length === 0) {
      return res.status(404).json({ error: 'No JSTIG rules found for this STIG ID' });
    }

    // Get findings for this system
    const systemFindings = await storage.getFindingsBySystem(systemId);
    
    // Build checklist items
    const checklistItems = jstigRules.map(rule => {
      const relatedFindings = systemFindings.filter(f => f.stigRuleId === rule.id);
      const openFindings = relatedFindings.filter(f => f.status === 'open');
      
      let status: 'pass' | 'fail' | 'not_reviewed';
      let comments = '';
      
      if (relatedFindings.length === 0) {
        status = 'not_reviewed';
        comments = 'No findings identified - requires manual review';
      } else if (openFindings.length === 0) {
        status = 'pass';
        comments = `${relatedFindings.length} findings resolved`;
      } else {
        status = 'fail';
        comments = `${openFindings.length} open findings require remediation`;
      }

      return {
        ruleId: rule.id,
        ruleType: rule.ruleType || 'jstig',
        title: rule.title,
        severity: rule.severity,
        description: rule.description,
        checkText: rule.checkText,
        fixText: rule.fixText,
        status,
        comments,
        findingsCount: relatedFindings.length,
        openFindingsCount: openFindings.length,
        lastAssessed: new Date().toISOString()
      };
    });

    // Calculate summary statistics
    const totalRules = checklistItems.length;
    const passedRules = checklistItems.filter(item => item.status === 'pass').length;
    const failedRules = checklistItems.filter(item => item.status === 'fail').length;
    const notReviewedRules = checklistItems.filter(item => item.status === 'not_reviewed').length;
    
    const checklist = {
      stigId,
      systemId,
      ruleType: 'jstig',
      title: `JSTIG Checklist for ${stigId}`,
      generatedAt: new Date().toISOString(),
      summary: {
        totalRules,
        passedRules,
        failedRules,
        notReviewedRules,
        compliancePercentage: Math.round((passedRules / totalRules) * 100),
        ruleType: 'jstig'
      },
      items: checklistItems
    };

    // Save checklist to database
    const checklistRecord = await storage.createChecklist({
      systemId,
      stigId,
      stigName: stigId,
      title: checklist.title,
      content: checklist,
      items: checklistItems,
      findings: totalRules,
      compliant: passedRules,
      completionStatus: 'completed',
      generatedBy: 'ai_generated'
    });

    if (format === 'json') {
      res.json(checklist);
    } else {
      res.status(400).json({ error: 'Unsupported format. Use format=json' });
    }

  } catch (error) {
    console.error('Error generating JSTIG checklist:', error);
    res.status(500).json({ error: 'Failed to generate JSTIG checklist' });
  }
});

/**
 * GET /api/assessment/rules/types
 * Get available rule types (STIG/JSTIG) and summary
 */
router.get('/rules/types', async (req, res) => {
  try {
    const { systemId } = req.query;

    // Get counts for both STIG and JSTIG rules
    const [stigRules, jstigRules] = await Promise.all([
      storage.getStigRulesByType('stig'),
      storage.getStigRulesByType('jstig')
    ]);

    const ruleTypeSummary = {
      stig: {
        totalRules: stigRules.length,
        availableStigs: Array.from(new Set(stigRules.map(r => r.stigId))).length,
        severityBreakdown: {
          critical: stigRules.filter(r => r.severity === 'critical').length,
          high: stigRules.filter(r => r.severity === 'high').length,
          medium: stigRules.filter(r => r.severity === 'medium').length,
          low: stigRules.filter(r => r.severity === 'low').length,
          informational: stigRules.filter(r => r.severity === 'informational').length
        }
      },
      jstig: {
        totalRules: jstigRules.length,
        availableStigs: Array.from(new Set(jstigRules.map(r => r.stigId))).length,
        severityBreakdown: {
          critical: jstigRules.filter(r => r.severity === 'critical').length,
          high: jstigRules.filter(r => r.severity === 'high').length,
          medium: jstigRules.filter(r => r.severity === 'medium').length,
          low: jstigRules.filter(r => r.severity === 'low').length,
          informational: jstigRules.filter(r => r.severity === 'informational').length
        }
      }
    };

    // If systemId provided, include findings breakdown for that system
    if (systemId && typeof systemId === 'string') {
      const systemFindings = await storage.getFindingsBySystem(systemId);
      
      const stigFindings = systemFindings.filter(f => {
        const matchingStig = stigRules.find(r => r.id === f.stigRuleId);
        return matchingStig?.ruleType === 'stig';
      });
      
      const jstigFindings = systemFindings.filter(f => {
        const matchingJstig = jstigRules.find(r => r.id === f.stigRuleId);
        return matchingJstig?.ruleType === 'jstig';
      });

      (ruleTypeSummary.stig as any).systemFindings = {
        total: stigFindings.length,
        open: stigFindings.filter(f => f.status === 'open').length,
        resolved: stigFindings.filter(f => f.status === 'fixed' || f.status === 'accepted').length
      };

      (ruleTypeSummary.jstig as any).systemFindings = {
        total: jstigFindings.length,
        open: jstigFindings.filter(f => f.status === 'open').length,
        resolved: jstigFindings.filter(f => f.status === 'fixed' || f.status === 'accepted').length
      };
    }

    res.json({
      summary: ruleTypeSummary,
      supportedRuleTypes: ['stig', 'jstig'],
      defaultRuleType: 'stig'
    });

  } catch (error) {
    console.error('Error getting rule types summary:', error);
    res.status(500).json({ error: 'Failed to get rule types summary' });
  }
});

// ========== BULK OPERATIONS ==========

/**
 * POST /api/assessment/bulk/assess
 * Trigger assessments for multiple systems
 */
router.post('/bulk/assess', async (req, res) => {
  try {
    const { systemIds, assessmentOptions } = BulkAssessmentSchema.parse(req.body);
    
    const results = [];
    const errors = [];

    for (const systemId of systemIds) {
      try {
        // Verify system exists
        const system = await storage.getSystem(systemId);
        if (!system) {
          errors.push({ systemId, error: 'System not found' });
          continue;
        }

        // Check for existing assessment
        const activeAssessments = assessmentEngine.getActiveAssessments();
        const existingAssessment = activeAssessments.find(a => 
          a.systemId === systemId && a.status === 'running'
        );

        if (existingAssessment) {
          errors.push({ 
            systemId, 
            error: 'Assessment already in progress',
            assessmentId: existingAssessment.assessmentId 
          });
          continue;
        }

        // Start assessment
        const options = assessmentOptions || {
          assessmentMode: 'automated' as const,
          includeInformationalFindings: false,
          generatePoamItems: true,
          generateEvidence: true,
          updateControlStatus: true,
          riskTolerance: 'medium' as const
        };

        const assessment = await assessmentEngine.assessSystem(systemId, options as AssessmentOptions);
        
        results.push({
          systemId,
          assessmentId: assessment.assessmentId,
          status: assessment.status,
          startTime: assessment.startTime
        });

      } catch (error) {
        errors.push({ 
          systemId, 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      }
    }

    res.status(202).json({
      message: `Bulk assessment initiated for ${results.length} systems`,
      results,
      errors,
      summary: {
        requested: systemIds.length,
        started: results.length,
        failed: errors.length
      }
    });

  } catch (error) {
    console.error('Error in bulk assessment:', error);
    
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Invalid request data',
        details: error.errors
      });
    }
    
    res.status(500).json({ error: 'Failed to start bulk assessment' });
  }
});

// ========== UTILITY ENDPOINTS ==========

/**
 * GET /api/assessment/health
 * Health check for assessment engine
 */
router.get('/health', (req, res) => {
  const activeAssessments = assessmentEngine.getActiveAssessments();
  const runningAssessments = activeAssessments.filter(a => a.status === 'running').length;
  
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    activeAssessments: activeAssessments.length,
    runningAssessments,
    memoryUsage: process.memoryUsage(),
    uptime: process.uptime()
  });
});

/**
 * POST /api/assessment/cleanup
 * Clean up old completed assessments
 */
router.post('/cleanup', (req, res) => {
  const { olderThanHours = 24 } = req.body;
  
  try {
    assessmentEngine.cleanupAssessments(olderThanHours);
    const remainingAssessments = assessmentEngine.getActiveAssessments().length;
    
    res.json({
      message: 'Assessment cleanup completed',
      remainingAssessments,
      cleanupThreshold: `${olderThanHours} hours`
    });
  } catch (error) {
    console.error('Error during cleanup:', error);
    res.status(500).json({ error: 'Failed to cleanup assessments' });
  }
});

export default router;