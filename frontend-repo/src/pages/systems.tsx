import { useState, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { SystemCard } from "@/components/system-card";
import { SystemRegistrationModal } from "@/components/system-registration-modal";
import { SystemEditModal } from "@/components/system-edit-modal";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Progress } from "@/components/ui/progress";
import { useToast } from "@/hooks/use-toast";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { Plus, Search, Filter, AlertCircle, FileText, Download, Clock, CheckCircle, Copy } from "lucide-react";
import type { System, ImpactLevelType, ComplianceStatusType } from "@shared/schema";

// Generate a text preview for SCTM documents
const generateSCTMPreview = (doc: any) => {
  const content = doc.content || {};
  const systemName = content.systemName || 'Unknown System';
  const totalControls = content.totalControls || 0;
  const templateName = content.templateName || 'SCTM Template';
  
  let preview = `# Security Control Traceability Matrix
## ${systemName}

**Document Type:** Security Control Traceability Matrix (Excel Format)
**Template:** ${templateName}
**Total Controls:** ${totalControls}
**Generated:** ${new Date().toLocaleString()}

## Document Summary
This SCTM document contains a comprehensive traceability matrix showing:
- Security control implementation status
- STIG rule mappings and compliance
- Evidence references and documentation
- Findings and vulnerability assessments
- LLM-generated implementation descriptions

## Preview Note
ðŸ“Š **This is an Excel document** - The full SCTM contains detailed control information in spreadsheet format with:
- Color-coded implementation status
- Sortable and filterable control data
- Professional formatting for compliance reviews
- Multiple worksheets with summary data

**To view the complete document:** Click the Download button to save as Excel (.xlsx) file

---
*Generated by ATO Compliance Agent with intelligent LLM-enhanced content*`;
  
  return preview;
};

// Define DocumentType locally
type DocumentType = 
  | 'ssp'
  | 'stig_checklist'
  | 'jsig_checklist'
  | 'sar_package' 
  | 'poam_report'
  | 'control_narratives'
  | 'evidence_summary'
  | 'complete_ato_package'
  | 'sctm_excel'
  | 'rar'
  | 'pps_worksheet';

export default function Systems() {
  const [searchTerm, setSearchTerm] = useState("");
  const [filterImpact, setFilterImpact] = useState<string>("");
  const [isRegistrationModalOpen, setIsRegistrationModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [systemToEdit, setSystemToEdit] = useState<System | null>(null);
  const [deletingSystemId, setDeletingSystemId] = useState<string | null>(null);
  const [location, setLocation] = useLocation();
  const { toast } = useToast();
  
  // Helper function to get display names for document types
  const getDocumentDisplayName = (docType: DocumentType | null): string => {
    if (!docType) return 'Document';
    
    const displayNames: Record<DocumentType, string> = {
      'ssp': 'System Security Plan (SSP)',
      'stig_checklist': 'STIG Checklists',
      'jsig_checklist': 'JSIG Checklists',
      'control_narratives': 'Control Narratives',
      'poam_report': 'POA&M Report',
      'sar_package': 'SAR Package',
      'evidence_summary': 'Evidence Summary',
      'complete_ato_package': 'Complete ATO Package',
      'sctm_excel': 'Security Control Traceability Matrix',
      'rar': 'Risk Assessment Report',
      'pps_worksheet': 'Privacy Impact Assessment Worksheet'
    };
    
    return displayNames[docType] || docType;
  };
  
  // Document Generation modal state
  const [documentModalOpen, setDocumentModalOpen] = useState(false);
  const [generatingSystemId, setGeneratingSystemId] = useState<string | null>(null);
  const [generatingDocumentType, setGeneratingDocumentType] = useState<DocumentType | null>(null);
  const [generationJobId, setGenerationJobId] = useState<string | null>(null);
  const [generationProgress, setGenerationProgress] = useState(0);
  const [generationStatus, setGenerationStatus] = useState<'generating' | 'completed' | 'failed'>('generating');
  const [generatedDocument, setGeneratedDocument] = useState<string | null>(null);


  // Fetch systems from API
  const { data: systemsResponse, isLoading, error, refetch } = useQuery({
    queryKey: ['/api/systems'],
    staleTime: 5 * 60 * 1000, // 5 minutes
  }) as { data: { systems: System[], totalCount: number } | undefined, isLoading: boolean, error: Error | null, refetch: () => void };

  // Extract systems array from response
  const systems = (systemsResponse?.systems || []).filter((system): system is System => Boolean(system && system.name));

  // Delete system mutation
  const deleteSystemMutation = useMutation({
    mutationFn: async (systemId: string) => {
      const response = await apiRequest('DELETE', `/api/systems/${systemId}`);
      return response.json();
    },
    onSuccess: () => {
      setDeletingSystemId(null);
      queryClient.invalidateQueries({ queryKey: ['/api/systems'] });
      toast({
        title: "Success",
        description: "System deleted successfully",
      });
    },
    onError: (error: Error) => {
      setDeletingSystemId(null);
      toast({
        title: "Error",
        description: `Failed to delete system: ${error.message}`,
        variant: "destructive",
      });
    },
  });

  // Calculate additional data for each system (temporarily mock implementation counts)
  const enrichedSystems = systems.map(system => ({
    ...system,
    controlsImplemented: Math.floor(Math.random() * 200) + 50, // TODO: Get from controls API
    totalControls: system.impactLevel === 'High' ? 324 : system.impactLevel === 'Moderate' ? 183 : 78,
    lastAssessment: '2 days ago', // TODO: Get from assessments API
  }));

  const filteredSystems = enrichedSystems.filter(system => {
    const matchesSearch = system.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         (system.description?.toLowerCase().includes(searchTerm.toLowerCase()) ?? false) ||
                         system.category.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = !filterImpact || system.impactLevel === filterImpact;
    return matchesSearch && matchesFilter;
  });

  const handleViewSystem = (systemId: string) => {
    // Navigate to system detail page
    setLocation(`/systems/${systemId}`);
  };

  const handleGenerateDocument = async (systemId: string, documentType: DocumentType) => {
    const system = systems.find(s => s.id === systemId);
    if (!system) {
      toast({
        title: "Error",
        description: "System not found",
        variant: "destructive",
      });
      return;
    }

    // Open modal and start generation
    setGeneratingSystemId(systemId);
    setGeneratingDocumentType(documentType);
    setDocumentModalOpen(true);
    setGenerationStatus('generating');
    setGenerationProgress(0);
    setGeneratedDocument(null);

    try {
      const response = await apiRequest('POST', '/api/generation/start', {
        systemId: systemId,
        documentTypes: [documentType],
        includeEvidence: true,
        includeArtifacts: true,
        templateOptions: {
          organization: system.category || 'Organization',
          customFields: {
            systemName: system.name,
            description: system.description || `${documentType} generation`
          }
        }
      });

      if (response.ok) {
        const result = await response.json();
        setGenerationJobId(result.jobId);
        pollGenerationStatus(result.jobId, documentType);
      } else {
        throw new Error(`Failed to start ${documentType} generation`);
      }
    } catch (error) {
      setGenerationStatus('failed');
      toast({
        title: "Error",
        description: `Failed to generate ${documentType}: ${error instanceof Error ? error.message : 'Unknown error'}`,
        variant: "destructive",
      });
    }
  };

  // Poll generation status and update progress
  const pollGenerationStatus = async (jobId: string, docType: DocumentType) => {
    try {
      const response = await apiRequest('GET', `/api/generation/status/${jobId}`);
      if (response.ok) {
        const result = await response.json();
        const status = result.status || result;
        setGenerationProgress(status.progress || 0);
        
        if (status.status === 'completed') {
          console.log('Generation completed, fetching document...');
          setGenerationStatus('completed');
          // Fetch the generated document
          try {
            await fetchGeneratedDocument(jobId, docType);
            console.log('Document fetch completed');
          } catch (error) {
            console.error('Error fetching document:', error);
            setGeneratedDocument('Error fetching document content.');
          }
        } else if (status.status === 'failed') {
          setGenerationStatus('failed');
        } else {
          // Continue polling
          setTimeout(() => pollGenerationStatus(jobId, docType), 2000);
        }
      }
    } catch (error) {
      console.error('Error polling generation status:', error);
      setGenerationStatus('failed');
    }
  };

  // Fetch the generated document content
  const fetchGeneratedDocument = async (jobId: string, docType: DocumentType) => {
    try {
      console.log('Fetching generated document for job:', jobId, 'type:', docType);
      const response = await apiRequest('GET', `/api/generation/result/${jobId}`);
      if (response.ok) {
        const result = await response.json();
        console.log('Generation result:', result);
        
        // Check for documents first (SSP, control narratives, etc.)
        const documents = result.result?.documents || [];
        const checklists = result.result?.checklists || [];
        const poamItems = result.result?.poamItems || [];
        
        // Handle different document types
        if (docType === 'stig_checklist' || docType === 'jsig_checklist') {
          // Handle STIG/JSIG checklists which are stored separately
          console.log(`${docType} found:`, checklists);
          if (checklists.length > 0) {
            const checklist = checklists[0];
            console.log('Using checklist:', checklist);
            
            // Check if checklist has content field first, then fallback to items
            let checklistContent;
            if (checklist.content && typeof checklist.content === 'string' && checklist.content.length > 10) {
              console.log('Using checklist content field');
              checklistContent = checklist.content;
            } else if (checklist.items && typeof checklist.items === 'object') {
              console.log('Using checklist items field as fallback');
              checklistContent = formatChecklistContent(checklist);
            } else {
              console.log('No valid content found in checklist');
              checklistContent = `No content available for ${getDocumentDisplayName(docType)}.`;
            }
            
            console.log('Setting generated document, content length:', checklistContent.length);
            setGeneratedDocument(checklistContent);
          } else {
            console.log('No checklists found in result');
            setGeneratedDocument(`No ${getDocumentDisplayName(docType)} found in the generation result.`);
          }
        } else if (docType === 'poam_report') {
          // Handle POA&M reports
          console.log('POA&M items found:', poamItems);
          if (poamItems.length > 0) {
            const poamContent = formatPoamContent(poamItems);
            console.log('Setting generated POA&M document, content length:', poamContent.length);
            setGeneratedDocument(poamContent);
          } else {
            console.log('No POA&M items found in result');
            setGeneratedDocument('No POA&M items found in the generation result.');
          }
        } else {
          // Handle regular documents (SSP, control narratives, SAR, etc.)
          const targetDoc = documents.find((doc: any) => doc.type === docType);
          
          if (targetDoc) {
            console.log('Found target document:', targetDoc);
            // Check if content is meaningful (string and longer than 10 characters)
            if (targetDoc.content && typeof targetDoc.content === 'string' && targetDoc.content.length > 10) {
              console.log('Using content field, length:', targetDoc.content.length);
              setGeneratedDocument(targetDoc.content);
            } else if (targetDoc.documentContent && typeof targetDoc.documentContent === 'string' && targetDoc.documentContent.length > 10) {
              console.log('Using documentContent field, length:', targetDoc.documentContent.length);
              
              // Check if this is a binary document (Excel, Word, etc.)
              if (targetDoc.type === 'sctm_excel' || targetDoc.type === 'rar_excel') {
                // Create a preview for SCTM documents
                const previewContent = generateSCTMPreview(targetDoc);
                setGeneratedDocument(previewContent);
              } else if (targetDoc.type === 'ssp' || targetDoc.type === 'sar') {
                setGeneratedDocument('ðŸ“„ Word document generated successfully. Use the download button to save the file.');
              } else {
                setGeneratedDocument(targetDoc.documentContent);
              }
            } else if (targetDoc.content && targetDoc.content.documentContent && typeof targetDoc.content.documentContent === 'string' && targetDoc.content.documentContent.length > 10) {
              console.log('Using nested content.documentContent field, length:', targetDoc.content.documentContent.length);
              
              // Check if this is a binary document (Excel, Word, etc.)
              if (targetDoc.type === 'sctm_excel' || targetDoc.type === 'rar_excel') {
                // Create a preview for SCTM documents
                const previewContent = generateSCTMPreview(targetDoc);
                setGeneratedDocument(previewContent);
              } else if (targetDoc.type === 'ssp' || targetDoc.type === 'sar') {
                setGeneratedDocument('ðŸ“„ Word document generated successfully. Use the download button to save the file.');
              } else {
                setGeneratedDocument(targetDoc.content.documentContent);
              }
            } else if (targetDoc.summary && typeof targetDoc.summary === 'string' && targetDoc.summary.length > 10) {
              console.log('Using summary field as fallback, length:', targetDoc.summary.length);
              setGeneratedDocument(targetDoc.summary);
            } else {
              console.log('Target document found but no meaningful content');
              const formattedContent = formatGenericDocument(targetDoc);
              setGeneratedDocument(formattedContent);
            }
          } else {
            console.log('No documents found in result');
            setGeneratedDocument(`No ${getDocumentDisplayName(docType)} found in the generation result.`);
          }
        }
      } else {
        console.error('Failed to fetch generation result:', response.status, response.statusText);
        setGeneratedDocument(`Error: Failed to fetch generation result (${response.status})`);
      }
    } catch (error) {
      console.error('Error fetching generated document:', error);
      setGeneratedDocument(`Error fetching document: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  // Format checklist content for display
  const formatChecklistContent = (checklist: any): string => {
    const items = checklist.items || {};
    const findings = items.findings || [];
    const metadata = items.checklistMetadata || {};
    
    let content = `STIG CHECKLIST REPORT\n`;
    content += `========================\n\n`;
    content += `System: ${metadata.systemName || 'Unknown'}\n`;
    content += `Assessment Date: ${metadata.assessmentDate || 'Unknown'}\n`;
    content += `Total Rules Assessed: ${metadata.totalRules || 0}\n`;
    content += `STIG Name: ${checklist.stigName || 'Unknown'}\n`;
    content += `Version: ${checklist.version || 'Unknown'}\n\n`;
    
    if (metadata.summaryStats) {
      content += `SUMMARY STATISTICS:\n`;
      content += `- Open Findings: ${metadata.summaryStats.open || 0}\n`;
      content += `- Not a Finding: ${metadata.summaryStats.notAFinding || 0}\n`;
      content += `- Not Applicable: ${metadata.summaryStats.notApplicable || 0}\n\n`;
    }
    
    content += `DETAILED FINDINGS:\n`;
    content += `==================\n\n`;
    
    findings.forEach((finding: any, index: number) => {
      content += `${index + 1}. ${finding.title}\n`;
      content += `   Vulnerability ID: ${finding.vulnerabilityId}\n`;
      content += `   STIG ID: ${finding.stigId}\n`;
      content += `   Severity: ${finding.severity}\n`;
      content += `   Status: ${finding.status}\n`;
      content += `   Finding Details: ${finding.findingDetails}\n`;
      content += `   Comments: ${finding.comments}\n`;
      
      if (finding.evidence && finding.evidence.length > 0) {
        content += `   Evidence:\n`;
        finding.evidence.forEach((evidence: string) => {
          content += `     - ${evidence}\n`;
        });
      }
      
      if (finding.nisControlMappings && finding.nisControlMappings.length > 0) {
        content += `   NIST Control Mappings: ${finding.nisControlMappings.join(', ')}\n`;
      }
      
      if (finding.recommendedAction) {
        content += `   Recommended Action: ${finding.recommendedAction}\n`;
      }
      
      content += `\n`;
    });
    
    if (items.riskSummary) {
      content += `RISK SUMMARY:\n`;
      content += `${items.riskSummary}\n\n`;
    }
    
    if (items.recommendations && items.recommendations.length > 0) {
      content += `RECOMMENDATIONS:\n`;
      items.recommendations.forEach((rec: string, index: number) => {
        content += `${index + 1}. ${rec}\n`;
      });
    }
    
    return content;
  };

  // Format POA&M content for display
  const formatPoamContent = (poamItems: any[]): string => {
    console.log('Formatting POA&M data:', poamItems);
    
    let content = `PLAN OF ACTION & MILESTONES (POA&M) REPORT\n`;
    content += `==========================================\n\n`;
    content += `Generated: ${new Date().toLocaleDateString()}\n`;
    content += `Total Items: ${poamItems.length}\n\n`;
    
    poamItems.forEach((item: any, index: number) => {
      content += `${index + 1}. ${item.weakness || 'Unnamed Item'}\n`;
      content += `   POA&M ID: ${item.poamId}\n`;
      content += `   Control: ${item.controlId || 'N/A'}\n`;
      content += `   Severity: ${item.severity || 'Medium'}\n`;
      content += `   Status: ${item.status || 'Open'}\n`;
      
      if (item.description) {
        content += `   Description: ${item.description}\n`;
      }
      
      if (item.milestones && item.milestones.length > 0) {
        content += `   Milestones:\n`;
        item.milestones.forEach((milestone: any) => {
          content += `     - ${milestone.description} (Due: ${new Date(milestone.dueDate).toLocaleDateString()})\n`;
        });
      }
      
      if (item.resources) {
        content += `   Resources: ${item.resources}\n`;
      }
      
      content += `\n`;
    });
    
    return content;
  };

  // Format generic document content for display
  const formatGenericDocument = (document: any): string => {
    console.log('Formatting generic document:', document);
    
    let content = `${getDocumentDisplayName(document.type || 'document').toUpperCase()}\n`;
    content += `${'='.repeat(getDocumentDisplayName(document.type || 'document').length)}\n\n`;
    
    if (document.metadata) {
      content += `METADATA\n`;
      content += `--------\n`;
      if (document.metadata.title) content += `Title: ${document.metadata.title}\n`;
      if (document.metadata.version) content += `Version: ${document.metadata.version}\n`;
      if (document.metadata.date) content += `Date: ${document.metadata.date}\n`;
      if (document.metadata.classification) content += `Classification: ${document.metadata.classification}\n`;
      content += `\n`;
    }
    
    // Add any content fields
    if (document.content && typeof document.content === 'string' && document.content.length > 10) {
      content += `CONTENT\n`;
      content += `--------\n\n`;
      content += document.content;
    } else if (document.documentContent && typeof document.documentContent === 'string' && document.documentContent.length > 10) {
      content += `CONTENT\n`;
      content += `--------\n\n`;
      content += document.documentContent;
    } else if (document.content && document.content.documentContent && typeof document.content.documentContent === 'string' && document.content.documentContent.length > 10) {
      content += `CONTENT\n`;
      content += `--------\n\n`;
      content += document.content.documentContent;
    } else if (document.summary && typeof document.summary === 'string' && document.summary.length > 10) {
      content += `SUMMARY\n`;
      content += `--------\n\n`;
      content += document.summary;
    } else {
      content += `No content available for this document.\n`;
    }
    
    return content;
  };

  const handleNewSystem = () => {
    setIsRegistrationModalOpen(true);
  };

  const handleEditSystem = (systemId: string) => {
    const system = systems.find(s => s.id === systemId);
    if (system) {
      setSystemToEdit(system);
      setIsEditModalOpen(true);
    } else {
      toast({
        title: "Error",
        description: "System not found",
        variant: "destructive",
      });
    }
  };

  const handleDeleteSystem = (systemId: string) => {
    setDeletingSystemId(systemId);
    deleteSystemMutation.mutate(systemId);
  };

  const stats = {
    total: enrichedSystems.length,
    highImpact: enrichedSystems.filter(s => s.impactLevel === "High").length,
    moderateImpact: enrichedSystems.filter(s => s.impactLevel === "Moderate").length,
    lowImpact: enrichedSystems.filter(s => s.impactLevel === "Low").length,
    compliant: enrichedSystems.filter(s => s.complianceStatus === "compliant").length,
  };

  return (
    <div className="space-y-6" data-testid="systems-page">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">IT Systems</h1>
          <p className="text-muted-foreground">
            Manage your organization's IT systems and their compliance status
          </p>
        </div>
        <Button onClick={handleNewSystem} data-testid="button-new-system">
          <Plus className="h-4 w-4 mr-2" />
          Register System
        </Button>
      </div>

      {/* Loading State */}
      {isLoading && (
        <div className="space-y-4">
          <div className="grid gap-4 md:grid-cols-4">
            {[...Array(4)].map((_, i) => (
              <Card key={i}>
                <CardHeader className="pb-2">
                  <Skeleton className="h-4 w-24" />
                </CardHeader>
                <CardContent>
                  <Skeleton className="h-8 w-16" />
                  <Skeleton className="h-3 w-20 mt-1" />
                </CardContent>
              </Card>
            ))}
          </div>
          <div className="space-y-4">
            <div className="flex flex-col sm:flex-row gap-4">
              <Skeleton className="h-10 flex-1" />
              <div className="flex gap-2">
                <Skeleton className="h-10 w-32" />
                <Skeleton className="h-10 w-24" />
              </div>
            </div>
            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
              {[...Array(6)].map((_, i) => (
                <Card key={i} className="h-64">
                  <CardHeader>
                    <Skeleton className="h-6 w-48" />
                    <Skeleton className="h-4 w-32" />
                  </CardHeader>
                  <CardContent className="space-y-4">
                    <Skeleton className="h-4 w-full" />
                    <Skeleton className="h-4 w-full" />
                    <Skeleton className="h-8 w-24" />
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Error State */}
      {error && (
        <Card className="border-destructive">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-destructive">
              <AlertCircle className="h-5 w-5" />
              Error Loading Systems
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-muted-foreground">{error.message}</p>
            <Button onClick={() => refetch()} variant="outline">
              Try Again
            </Button>
          </CardContent>
        </Card>
      )}

      {/* Systems Overview Cards */}
      {!isLoading && !error && (
        <>
          <div className="grid gap-4 md:grid-cols-4">
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Total Systems</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.total}</div>
                <p className="text-xs text-muted-foreground">Registered systems</p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">High Impact</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.highImpact}</div>
                <p className="text-xs text-muted-foreground">Critical systems</p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Moderate Impact</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.moderateImpact}</div>
                <p className="text-xs text-muted-foreground">Important systems</p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Compliant</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.compliant}</div>
                <p className="text-xs text-muted-foreground">Fully compliant</p>
              </CardContent>
            </Card>
          </div>

          <div className="flex flex-col sm:flex-row gap-4">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search systems by name, description, or category..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10"
                data-testid="input-search-systems"
              />
            </div>
            <div className="flex gap-2">
              <select
                value={filterImpact}
                onChange={(e) => setFilterImpact(e.target.value)}
                className="px-3 py-2 border border-input bg-background rounded-md text-sm"
                data-testid="select-filter-impact"
              >
                <option value="">All Impact Levels</option>
                <option value="High">High</option>
                <option value="Moderate">Moderate</option>
                <option value="Low">Low</option>
              </select>
              <Button variant="outline" size="sm">
                <Filter className="h-4 w-4 mr-2" />
                More Filters
              </Button>
            </div>
          </div>

          {filteredSystems.length === 0 ? (
            <Card>
              <CardContent className="py-8 text-center">
                <p className="text-muted-foreground mb-2">No systems found</p>
                <p className="text-sm text-muted-foreground">
                  {searchTerm || filterImpact ? 'Try adjusting your search or filter criteria.' : 'Get started by registering your first system.'}
                </p>
                {!searchTerm && !filterImpact && (
                  <Button 
                    className="mt-4" 
                    onClick={handleNewSystem}
                    data-testid="button-register-first-system"
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Register System
                  </Button>
                )}
              </CardContent>
            </Card>
          ) : (
            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
              {filteredSystems.map((system) => (
                <SystemCard
                  key={system.id}
                  system={system}
                  onEdit={() => handleEditSystem(system.id)}
                  onDelete={() => handleDeleteSystem(system.id)}
                  onView={() => handleViewSystem(system.id)}
                  onDocumentGenerate={handleGenerateDocument}
                  onStartGuidedWorkflow={(systemId) => setLocation(`/systems/${systemId}/ato-workflow`)}
                />
              ))}
            </div>
          )}

          <div className="flex items-center justify-between text-sm text-muted-foreground">
            <div>
              Showing {filteredSystems.length} of {enrichedSystems.length} systems
            </div>
          </div>
        </>
      )}

      <SystemRegistrationModal 
        open={isRegistrationModalOpen}
        onOpenChange={setIsRegistrationModalOpen}
      />
      
      <SystemEditModal
        system={systemToEdit}
        open={isEditModalOpen}
        onOpenChange={(open) => {
          setIsEditModalOpen(open);
          if (!open) {
            setSystemToEdit(null);
          }
        }}
      />

      {/* Document Generation Modal */}
      <Dialog open={documentModalOpen} onOpenChange={setDocumentModalOpen}>
        <DialogContent className="max-w-4xl h-[80vh] flex flex-col">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <FileText className="h-5 w-5" />
              {getDocumentDisplayName(generatingDocumentType)} Generation
              {generatingSystemId && ` - ${systems.find(s => s.id === generatingSystemId)?.name}`}
            </DialogTitle>
            <DialogDescription>
              Generating your ATO compliance document. This process may take a few minutes.
            </DialogDescription>
          </DialogHeader>

          <div className="flex-1 flex flex-col overflow-hidden">
            {generationStatus === 'generating' && (
              <div className="space-y-4 p-6">
                <div className="text-center space-y-2">
                  <Clock className="mx-auto h-12 w-12 text-primary animate-pulse" />
                  <h3 className="text-lg font-semibold">Generating {getDocumentDisplayName(generatingDocumentType)}...</h3>
                  <p className="text-muted-foreground">
                    Our AI is analyzing your system configuration and generating comprehensive security documentation.
                  </p>
                </div>
                
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Generation Progress</span>
                    <span>{Math.round(generationProgress)}%</span>
                  </div>
                  <Progress value={generationProgress} className="w-full" />
                </div>

                <div className="text-center text-sm text-muted-foreground">
                  This usually takes 2-3 minutes to complete...
                </div>
              </div>
            )}

            {generationStatus === 'completed' && (
              <div className="flex-1 flex flex-col space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2 text-green-600">
                    <CheckCircle className="h-5 w-5" />
                    <span className="font-semibold">{getDocumentDisplayName(generatingDocumentType)} Generated Successfully!</span>
                  </div>
                  <div className="flex gap-2">
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => {
                        if (generatedDocument) {
                          navigator.clipboard.writeText(generatedDocument);
                          toast({
                            title: "Copied!",
                            description: "Document content copied to clipboard",
                          });
                        }
                      }}
                    >
                      <Copy className="h-4 w-4 mr-2" />
                      Copy
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() => {
                        if (generatedDocument) {
                          const blob = new Blob([generatedDocument], { type: 'text/plain' });
                          const url = URL.createObjectURL(blob);
                          const a = document.createElement('a');
                          a.href = url;
                          a.download = `${getDocumentDisplayName(generatingDocumentType)}_${new Date().toISOString().split('T')[0]}.txt`;
                          document.body.appendChild(a);
                          a.click();
                          document.body.removeChild(a);
                          URL.revokeObjectURL(url);
                        }
                      }}
                    >
                      <Download className="h-4 w-4 mr-2" />
                      Download
                    </Button>
                  </div>
                </div>

                <div className="flex-1 border rounded-md overflow-hidden">
                  <div className="h-full max-h-[60vh] overflow-y-auto p-4 bg-background">
                    {generatedDocument ? (
                      <div className="prose prose-sm max-w-none dark:prose-invert">
                        <pre className="whitespace-pre-wrap text-sm font-mono leading-relaxed">
                          {generatedDocument}
                        </pre>
                      </div>
                    ) : (
                      <div className="flex items-center justify-center h-full text-muted-foreground">
                        Loading document content...
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}

            {generationStatus === 'failed' && (
              <div className="text-center space-y-4 p-6">
                <AlertCircle className="mx-auto h-12 w-12 text-destructive" />
                <div>
                  <h3 className="text-lg font-semibold text-destructive">Generation Failed</h3>
                  <p className="text-muted-foreground">
                    There was an error generating the {getDocumentDisplayName(generatingDocumentType)}. Please try again or contact support.
                  </p>
                </div>
                <Button 
                  onClick={() => generatingSystemId && generatingDocumentType && handleGenerateDocument(generatingSystemId, generatingDocumentType)}
                  variant="outline"
                >
                  Try Again
                </Button>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}